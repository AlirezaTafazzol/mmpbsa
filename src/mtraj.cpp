#include "libmmpbsa/mmpbsa_utils.h"

#include <cstdlib>
#include <cstdio>
#include <getopt.h>
#include <errno.h>
#include <cstring>
#include <vector>


void print_help()
{
  printf("mtraj -- Trajectory frame extractor.\nExtracts portions of an mdcrd trajectory file.\n");
  
  printf("Usage: mtraj [options]\n\n");
  
  printf("--input, -i FILE\tIndicates the input filename. If not provided, standard\n\t\t\tinput is used.\n");
  printf("--output, -o FILE\tIndicates the output filename. If not provided, standard\n\t\t\toutput is used.\n");
  printf("--first, -f INT\t\tSets the first snapshot (Default: 1)\n");
  printf("--last, -l INT\t\tSets the last snapshot number. If not provided, only\n\t\t\tone snapshot is extracted.\n");
  printf("--frame INT-INT\n--frame INT,..,INT\tExplicitly list the snapshots to be extracted. Cannot be used with -f or -l.\n");
  printf("--natoms, -n INT\tSets the number of atoms. (Required)\n");
  printf("--periodic, -p\t\tFlag to indicate whether box coordinates are provided\n\t\t\tin the file.\n");
  
}

enum {SNAP_LIST_FLAG};
struct option long_opts[] = {
  {"first",1,NULL,'f'},
  {"input",1,NULL,'i'},
  {"last",1,NULL,'l'},
  {"frames",1,NULL,SNAP_LIST_FLAG},
  {"natoms",1,NULL,'n'},
  {"output",1,NULL,'o'},
  {"periodic",0,NULL,'p'},
  {"help",0,NULL,'h'},
  {NULL,0,NULL,0}
};
static const char short_opts[] = "f:hi:l:n:o:ps:";

int main(int argc, char **argv)
{
  using std::vector;
  using mmpbsa_utils::loadListArg;
  int natoms,ifbox = 0;
  size_t num_lines,chars_per_snap,title_len;
  int snap_number = 1, last_snap = -1;
  char *buf = NULL;
  FILE *input = stdin;
  FILE *output = stdout;
  char optflag;
  vector<size_t> queue;
  vector<size_t>::const_iterator snapid;
  
  while((optflag = getopt_long(argc,argv,short_opts,long_opts,NULL)) != -1)
    {
      switch(optflag)
	{
	case SNAP_LIST_FLAG:
	  if(snap_number != 1 || last_snap > -1)
	    {
	      fprintf(stderr, "Cannot use both a snap shot list and first/last snap shot indicators.\n");
	      exit(-1);
	    }
	  loadListArg(optarg,queue,0);
	  break;
	case 'i':
	  input = fopen(optarg,"r");
	  if(input == NULL)
	    {
	      fprintf(stderr,"Could not open %s\nReason: %s\n",optarg,strerror(errno));
	      exit(errno);
	    }
	  break;
	case 'o':
	  output = fopen(optarg,"w");
	  if(output == NULL)
	    {
	      fprintf(stderr,"Could not open %s\nReason: %s\n",optarg,strerror(errno));
	      exit(errno);
	    }
	  break;
	case 'l':
	  if(sscanf(optarg,"%d",&last_snap) != 1)
	    {
	      fprintf(stderr,"Could not read integer value: %s\n",optarg);
	      exit(errno);
	    }
	  break;
	case 'f':
	  if(sscanf(optarg,"%d",&snap_number) != 1)
	    {
	      fprintf(stderr,"Could not read integer value: %s\n",optarg);
	      exit(errno);
	    }
	  break;
	case 'n':
	  if(sscanf(optarg,"%d",&natoms) != 1)
	    {
	      fprintf(stderr,"Could not read integer value: %s\n",optarg);
	      exit(errno);
	    }
	  break;
	case 'p':
	  ifbox = 1;
	  break;
	case 'h':
	  print_help();
	  exit(0);
	  break;
	default:
	  fprintf(stderr,"Unknown flag: %c",optflag);
	  fprintf(stderr,"Use mtraj --help for a list of options\n");
	  exit(-1);
	}
    }

  if(queue.size() == 0)
    {
      if(last_snap == -1)
	last_snap = snap_number;
      for(;snap_number <= last_snap;snap_number++)
	queue.push_back(snap_number);
    }

  if(queue.size() == 0)// if size is still zero, something's wrong
    {
      fprintf(stderr,"Empty list of snapshots\n");
      exit(-1);
    }

  num_lines = (natoms*3)/10;
  if(natoms*3%10 != 0)
    num_lines++;
	
  chars_per_snap = natoms*3*8 + num_lines;
  if(ifbox != 0)
    chars_per_snap += 25;
  
  snap_number = *(queue.begin());
  buf = (char*)calloc(chars_per_snap + 1,sizeof(char));
  title_len = getline(&buf,&num_lines,input);// skip title
  title_len = strlen(buf);
  fseek(input,chars_per_snap*(snap_number-1) + title_len,SEEK_SET);// snap_number is ONE-indexed
  fprintf(output,"trajectory generated by mtraj\n");

  for(snapid = queue.begin();snapid != queue.end();snapid++)
   {
     if(snap_number + 1 != *snapid)
       {
	 // If we go out of order, reset the file position.
	 fseek(input,chars_per_snap*(snap_number-1) + title_len,SEEK_SET);// snap_number is ONE-indexed
       }
     title_len = fread(buf,chars_per_snap,sizeof(char),input);
     fwrite(buf,chars_per_snap,sizeof(char),output);
     fflush(output);
     snap_number = *snapid;
    }

  if(input != NULL && input != stdin)
    fclose(input);
  if(output != NULL && output != stdout)
    fclose(output);
  if(buf != NULL)
    free(buf);
  return 0;

  
}

